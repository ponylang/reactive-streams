{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Packages reactive_streams","title":"reactive_streams"},{"location":"reactive_streams--index/","text":"No package doc string provided for reactive_streams. Public Types \u00b6 class Unicast interface Subscription class NoSubscription interface SubscriberManager interface Subscriber interface Publisher interface Processor interface ManagedPublisher trait ReactiveError primitive SubscribedAlready primitive PublisherFull class Broadcast","title":"Package"},{"location":"reactive_streams--index/#public-types","text":"class Unicast interface Subscription class NoSubscription interface SubscriberManager interface Subscriber interface Publisher interface Processor interface ManagedPublisher trait ReactiveError primitive SubscribedAlready primitive PublisherFull class Broadcast","title":"Public Types"},{"location":"reactive_streams-Broadcast/","text":"Broadcast[A: Any #share] \u00b6 [Source] Broadcasts data to all subscribers. class ref Broadcast[A: Any #share] is SubscriberManager[A] ref Implements \u00b6 SubscriberManager [A] ref Constructors \u00b6 create \u00b6 [Source] Create a Broadcast for a given ManagedPublisher. new ref create( pub: ManagedPublisher[A] tag, qbound: U64 val = call) : Broadcast[A] ref^ Parameters \u00b6 pub: ManagedPublisher [A] tag qbound: U64 val = call Returns \u00b6 Broadcast [A] ref^ Public Functions \u00b6 min_request \u00b6 [Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val Returns \u00b6 U64 val max_request \u00b6 [Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val Returns \u00b6 U64 val queue_bound \u00b6 [Source] Returns the queue bound. fun box queue_bound() : U64 val Returns \u00b6 U64 val queue_size \u00b6 [Source] Returns the current queue size. fun box queue_size() : U64 val Returns \u00b6 U64 val subscriber_count \u00b6 [Source] Returns the current subscriber count. fun box subscriber_count() : U64 val Returns \u00b6 U64 val publish \u00b6 [Source] Send data to all subscribers. fun ref publish( a: A) : None val Parameters \u00b6 a: A Returns \u00b6 None val on_complete \u00b6 [Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val Returns \u00b6 None val on_error \u00b6 [Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val Parameters \u00b6 e: ReactiveError val Returns \u00b6 None val on_subscribe \u00b6 [Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val on_request \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val Parameters \u00b6 sub: Subscriber [A] tag n: U64 val Returns \u00b6 None val on_cancel \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val","title":"class Broadcast"},{"location":"reactive_streams-Broadcast/#broadcasta-any-share","text":"[Source] Broadcasts data to all subscribers. class ref Broadcast[A: Any #share] is SubscriberManager[A] ref","title":"Broadcast[A: Any #share]"},{"location":"reactive_streams-Broadcast/#implements","text":"SubscriberManager [A] ref","title":"Implements"},{"location":"reactive_streams-Broadcast/#constructors","text":"","title":"Constructors"},{"location":"reactive_streams-Broadcast/#create","text":"[Source] Create a Broadcast for a given ManagedPublisher. new ref create( pub: ManagedPublisher[A] tag, qbound: U64 val = call) : Broadcast[A] ref^","title":"create"},{"location":"reactive_streams-Broadcast/#parameters","text":"pub: ManagedPublisher [A] tag qbound: U64 val = call","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns","text":"Broadcast [A] ref^","title":"Returns"},{"location":"reactive_streams-Broadcast/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-Broadcast/#min_request","text":"[Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val","title":"min_request"},{"location":"reactive_streams-Broadcast/#returns_1","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Broadcast/#max_request","text":"[Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val","title":"max_request"},{"location":"reactive_streams-Broadcast/#returns_2","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Broadcast/#queue_bound","text":"[Source] Returns the queue bound. fun box queue_bound() : U64 val","title":"queue_bound"},{"location":"reactive_streams-Broadcast/#returns_3","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Broadcast/#queue_size","text":"[Source] Returns the current queue size. fun box queue_size() : U64 val","title":"queue_size"},{"location":"reactive_streams-Broadcast/#returns_4","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Broadcast/#subscriber_count","text":"[Source] Returns the current subscriber count. fun box subscriber_count() : U64 val","title":"subscriber_count"},{"location":"reactive_streams-Broadcast/#returns_5","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Broadcast/#publish","text":"[Source] Send data to all subscribers. fun ref publish( a: A) : None val","title":"publish"},{"location":"reactive_streams-Broadcast/#parameters_1","text":"a: A","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns_6","text":"None val","title":"Returns"},{"location":"reactive_streams-Broadcast/#on_complete","text":"[Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val","title":"on_complete"},{"location":"reactive_streams-Broadcast/#returns_7","text":"None val","title":"Returns"},{"location":"reactive_streams-Broadcast/#on_error","text":"[Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val","title":"on_error"},{"location":"reactive_streams-Broadcast/#parameters_2","text":"e: ReactiveError val","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns_8","text":"None val","title":"Returns"},{"location":"reactive_streams-Broadcast/#on_subscribe","text":"[Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val","title":"on_subscribe"},{"location":"reactive_streams-Broadcast/#parameters_3","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns_9","text":"None val","title":"Returns"},{"location":"reactive_streams-Broadcast/#on_request","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val","title":"on_request"},{"location":"reactive_streams-Broadcast/#parameters_4","text":"sub: Subscriber [A] tag n: U64 val","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns_10","text":"None val","title":"Returns"},{"location":"reactive_streams-Broadcast/#on_cancel","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val","title":"on_cancel"},{"location":"reactive_streams-Broadcast/#parameters_5","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-Broadcast/#returns_11","text":"None val","title":"Returns"},{"location":"reactive_streams-ManagedPublisher/","text":"ManagedPublisher[A: Any #share] \u00b6 [Source] A ManagedPublisher must have a SubscriberManager and give access to it. interface tag ManagedPublisher[A: Any #share] is Publisher[A] tag Implements \u00b6 Publisher [A] tag Public Behaviours \u00b6 subscribe \u00b6 [Source] A ManagedPublisher must respond by calling SubscriberManager._on_subscribe. be subscribe( s: Subscriber[A] tag) Parameters \u00b6 s: Subscriber [A] tag on_request \u00b6 [Source] A ManagedPublisher must respond by calling SubscriberManager._on_request. be on_request( s: Subscriber[A] tag, n: U64 val) Parameters \u00b6 s: Subscriber [A] tag n: U64 val on_cancel \u00b6 [Source] A ManagedPublisher must respond by calling SubscriberManager._on_cancel. be on_cancel( s: Subscriber[A] tag) Parameters \u00b6 s: Subscriber [A] tag","title":"interface ManagedPublisher"},{"location":"reactive_streams-ManagedPublisher/#managedpublishera-any-share","text":"[Source] A ManagedPublisher must have a SubscriberManager and give access to it. interface tag ManagedPublisher[A: Any #share] is Publisher[A] tag","title":"ManagedPublisher[A: Any #share]"},{"location":"reactive_streams-ManagedPublisher/#implements","text":"Publisher [A] tag","title":"Implements"},{"location":"reactive_streams-ManagedPublisher/#public-behaviours","text":"","title":"Public Behaviours"},{"location":"reactive_streams-ManagedPublisher/#subscribe","text":"[Source] A ManagedPublisher must respond by calling SubscriberManager._on_subscribe. be subscribe( s: Subscriber[A] tag)","title":"subscribe"},{"location":"reactive_streams-ManagedPublisher/#parameters","text":"s: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-ManagedPublisher/#on_request","text":"[Source] A ManagedPublisher must respond by calling SubscriberManager._on_request. be on_request( s: Subscriber[A] tag, n: U64 val)","title":"on_request"},{"location":"reactive_streams-ManagedPublisher/#parameters_1","text":"s: Subscriber [A] tag n: U64 val","title":"Parameters"},{"location":"reactive_streams-ManagedPublisher/#on_cancel","text":"[Source] A ManagedPublisher must respond by calling SubscriberManager._on_cancel. be on_cancel( s: Subscriber[A] tag)","title":"on_cancel"},{"location":"reactive_streams-ManagedPublisher/#parameters_2","text":"s: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-NoSubscription/","text":"NoSubscription \u00b6 [Source] class ref NoSubscription is Subscription ref Implements \u00b6 Subscription ref Constructors \u00b6 create \u00b6 [Source] new iso create() : NoSubscription iso^ Returns \u00b6 NoSubscription iso^ Public Functions \u00b6 request \u00b6 [Source] fun ref request( n: U64 val) : None val Parameters \u00b6 n: U64 val Returns \u00b6 None val cancel \u00b6 [Source] fun ref cancel() : None val Returns \u00b6 None val","title":"class NoSubscription"},{"location":"reactive_streams-NoSubscription/#nosubscription","text":"[Source] class ref NoSubscription is Subscription ref","title":"NoSubscription"},{"location":"reactive_streams-NoSubscription/#implements","text":"Subscription ref","title":"Implements"},{"location":"reactive_streams-NoSubscription/#constructors","text":"","title":"Constructors"},{"location":"reactive_streams-NoSubscription/#create","text":"[Source] new iso create() : NoSubscription iso^","title":"create"},{"location":"reactive_streams-NoSubscription/#returns","text":"NoSubscription iso^","title":"Returns"},{"location":"reactive_streams-NoSubscription/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-NoSubscription/#request","text":"[Source] fun ref request( n: U64 val) : None val","title":"request"},{"location":"reactive_streams-NoSubscription/#parameters","text":"n: U64 val","title":"Parameters"},{"location":"reactive_streams-NoSubscription/#returns_1","text":"None val","title":"Returns"},{"location":"reactive_streams-NoSubscription/#cancel","text":"[Source] fun ref cancel() : None val","title":"cancel"},{"location":"reactive_streams-NoSubscription/#returns_2","text":"None val","title":"Returns"},{"location":"reactive_streams-Processor/","text":"Processor[A: Any #share, B: Any #share] \u00b6 [Source] A Processor represents a processing stage\u2014which is both a Subscriber and a Publisher and obeys the contracts of both. interface tag Processor[A: Any #share, B: Any #share] is Subscriber[A] tag, Publisher[B] tag Implements \u00b6 Subscriber [A] tag Publisher [B] tag Public Behaviours \u00b6 on_subscribe \u00b6 [Source] be on_subscribe( s: Subscription iso) Parameters \u00b6 s: Subscription iso on_next \u00b6 [Source] be on_next( a: A) Parameters \u00b6 a: A on_error \u00b6 [Source] be on_error( e: ReactiveError val) Parameters \u00b6 e: ReactiveError val on_complete \u00b6 [Source] be on_complete() subscribe \u00b6 [Source] be subscribe( s: Subscriber[B] tag) Parameters \u00b6 s: Subscriber [B] tag","title":"interface Processor"},{"location":"reactive_streams-Processor/#processora-any-share-b-any-share","text":"[Source] A Processor represents a processing stage\u2014which is both a Subscriber and a Publisher and obeys the contracts of both. interface tag Processor[A: Any #share, B: Any #share] is Subscriber[A] tag, Publisher[B] tag","title":"Processor[A: Any #share, B: Any #share]"},{"location":"reactive_streams-Processor/#implements","text":"Subscriber [A] tag Publisher [B] tag","title":"Implements"},{"location":"reactive_streams-Processor/#public-behaviours","text":"","title":"Public Behaviours"},{"location":"reactive_streams-Processor/#on_subscribe","text":"[Source] be on_subscribe( s: Subscription iso)","title":"on_subscribe"},{"location":"reactive_streams-Processor/#parameters","text":"s: Subscription iso","title":"Parameters"},{"location":"reactive_streams-Processor/#on_next","text":"[Source] be on_next( a: A)","title":"on_next"},{"location":"reactive_streams-Processor/#parameters_1","text":"a: A","title":"Parameters"},{"location":"reactive_streams-Processor/#on_error","text":"[Source] be on_error( e: ReactiveError val)","title":"on_error"},{"location":"reactive_streams-Processor/#parameters_2","text":"e: ReactiveError val","title":"Parameters"},{"location":"reactive_streams-Processor/#on_complete","text":"[Source] be on_complete()","title":"on_complete"},{"location":"reactive_streams-Processor/#subscribe","text":"[Source] be subscribe( s: Subscriber[B] tag)","title":"subscribe"},{"location":"reactive_streams-Processor/#parameters_3","text":"s: Subscriber [B] tag","title":"Parameters"},{"location":"reactive_streams-Publisher/","text":"Publisher[A: Any #share] \u00b6 [Source] A Publisher is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s). A Publisher can serve multiple Subscribers subscribed dynamically at various points in time. interface tag Publisher[A: Any #share] Public Behaviours \u00b6 subscribe \u00b6 [Source] Request Publisher to start streaming data. This is a \"factory method\" and can be called multiple times, each time starting a new Subscription. Each Subscription will work for only a single Subscriber. A Subscriber should only subscribe once to a single Publisher. If the Publisher rejects the subscription attempt or otherwise fails it will signal the error via Subscriber.on_error. be subscribe( s: Subscriber[A] tag) Parameters \u00b6 s: Subscriber [A] tag","title":"interface Publisher"},{"location":"reactive_streams-Publisher/#publishera-any-share","text":"[Source] A Publisher is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s). A Publisher can serve multiple Subscribers subscribed dynamically at various points in time. interface tag Publisher[A: Any #share]","title":"Publisher[A: Any #share]"},{"location":"reactive_streams-Publisher/#public-behaviours","text":"","title":"Public Behaviours"},{"location":"reactive_streams-Publisher/#subscribe","text":"[Source] Request Publisher to start streaming data. This is a \"factory method\" and can be called multiple times, each time starting a new Subscription. Each Subscription will work for only a single Subscriber. A Subscriber should only subscribe once to a single Publisher. If the Publisher rejects the subscription attempt or otherwise fails it will signal the error via Subscriber.on_error. be subscribe( s: Subscriber[A] tag)","title":"subscribe"},{"location":"reactive_streams-Publisher/#parameters","text":"s: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-PublisherFull/","text":"PublisherFull \u00b6 [Source] primitive val PublisherFull is ReactiveError val Implements \u00b6 ReactiveError val Constructors \u00b6 create \u00b6 [Source] new val create() : PublisherFull val^ Returns \u00b6 PublisherFull val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: PublisherFull val) : Bool val Parameters \u00b6 that: PublisherFull val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: PublisherFull val) : Bool val Parameters \u00b6 that: PublisherFull val Returns \u00b6 Bool val","title":"primitive PublisherFull"},{"location":"reactive_streams-PublisherFull/#publisherfull","text":"[Source] primitive val PublisherFull is ReactiveError val","title":"PublisherFull"},{"location":"reactive_streams-PublisherFull/#implements","text":"ReactiveError val","title":"Implements"},{"location":"reactive_streams-PublisherFull/#constructors","text":"","title":"Constructors"},{"location":"reactive_streams-PublisherFull/#create","text":"[Source] new val create() : PublisherFull val^","title":"create"},{"location":"reactive_streams-PublisherFull/#returns","text":"PublisherFull val^","title":"Returns"},{"location":"reactive_streams-PublisherFull/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-PublisherFull/#eq","text":"[Source] fun box eq( that: PublisherFull val) : Bool val","title":"eq"},{"location":"reactive_streams-PublisherFull/#parameters","text":"that: PublisherFull val","title":"Parameters"},{"location":"reactive_streams-PublisherFull/#returns_1","text":"Bool val","title":"Returns"},{"location":"reactive_streams-PublisherFull/#ne","text":"[Source] fun box ne( that: PublisherFull val) : Bool val","title":"ne"},{"location":"reactive_streams-PublisherFull/#parameters_1","text":"that: PublisherFull val","title":"Parameters"},{"location":"reactive_streams-PublisherFull/#returns_2","text":"Bool val","title":"Returns"},{"location":"reactive_streams-ReactiveError/","text":"ReactiveError \u00b6 [Source] trait val ReactiveError","title":"trait ReactiveError"},{"location":"reactive_streams-ReactiveError/#reactiveerror","text":"[Source] trait val ReactiveError","title":"ReactiveError"},{"location":"reactive_streams-SubscribedAlready/","text":"SubscribedAlready \u00b6 [Source] primitive val SubscribedAlready is ReactiveError val Implements \u00b6 ReactiveError val Constructors \u00b6 create \u00b6 [Source] new val create() : SubscribedAlready val^ Returns \u00b6 SubscribedAlready val^ Public Functions \u00b6 eq \u00b6 [Source] fun box eq( that: SubscribedAlready val) : Bool val Parameters \u00b6 that: SubscribedAlready val Returns \u00b6 Bool val ne \u00b6 [Source] fun box ne( that: SubscribedAlready val) : Bool val Parameters \u00b6 that: SubscribedAlready val Returns \u00b6 Bool val","title":"primitive SubscribedAlready"},{"location":"reactive_streams-SubscribedAlready/#subscribedalready","text":"[Source] primitive val SubscribedAlready is ReactiveError val","title":"SubscribedAlready"},{"location":"reactive_streams-SubscribedAlready/#implements","text":"ReactiveError val","title":"Implements"},{"location":"reactive_streams-SubscribedAlready/#constructors","text":"","title":"Constructors"},{"location":"reactive_streams-SubscribedAlready/#create","text":"[Source] new val create() : SubscribedAlready val^","title":"create"},{"location":"reactive_streams-SubscribedAlready/#returns","text":"SubscribedAlready val^","title":"Returns"},{"location":"reactive_streams-SubscribedAlready/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-SubscribedAlready/#eq","text":"[Source] fun box eq( that: SubscribedAlready val) : Bool val","title":"eq"},{"location":"reactive_streams-SubscribedAlready/#parameters","text":"that: SubscribedAlready val","title":"Parameters"},{"location":"reactive_streams-SubscribedAlready/#returns_1","text":"Bool val","title":"Returns"},{"location":"reactive_streams-SubscribedAlready/#ne","text":"[Source] fun box ne( that: SubscribedAlready val) : Bool val","title":"ne"},{"location":"reactive_streams-SubscribedAlready/#parameters_1","text":"that: SubscribedAlready val","title":"Parameters"},{"location":"reactive_streams-SubscribedAlready/#returns_2","text":"Bool val","title":"Returns"},{"location":"reactive_streams-Subscriber/","text":"Subscriber[A: Any #share] \u00b6 [Source] Will receive call to on_subscribe once after passing an instance of Subscriber to Publisher.subscribe. No further notifications will be received until Subscription.request is called. After signaling demand: One or more invocations of on_next up to the maximum number defined by Subscription.request Single invocation of on_error or on_complete which signals a terminal state after which no further events will be sent. Demand can be signaled via Subscription.request whenever the Subscriber instance is capable of handling more. interface tag Subscriber[A: Any #share] Public Behaviours \u00b6 on_subscribe \u00b6 [Source] Invoked after calling Publisher.subscribe. No data will start flowing until Subscription.request is invoked. It is the responsibility of this Subscriber instance to call Subscription.request whenever more data is wanted. The Publisher will send notifications only in response to Subscription.request. be on_subscribe( s: Subscription iso) Parameters \u00b6 s: Subscription iso on_next \u00b6 [Source] Data notification sent by the Publisher in response to requests to Subscription.request. be on_next( a: A) Parameters \u00b6 a: A on_error \u00b6 [Source] Failed terminal state. No further events will be sent even if Subscription.request is invoked again. be on_error( e: ReactiveError val) Parameters \u00b6 e: ReactiveError val on_complete \u00b6 [Source] Successful terminal state. No further events will be sent even if Subscription.request is invoked again. be on_complete()","title":"interface Subscriber"},{"location":"reactive_streams-Subscriber/#subscribera-any-share","text":"[Source] Will receive call to on_subscribe once after passing an instance of Subscriber to Publisher.subscribe. No further notifications will be received until Subscription.request is called. After signaling demand: One or more invocations of on_next up to the maximum number defined by Subscription.request Single invocation of on_error or on_complete which signals a terminal state after which no further events will be sent. Demand can be signaled via Subscription.request whenever the Subscriber instance is capable of handling more. interface tag Subscriber[A: Any #share]","title":"Subscriber[A: Any #share]"},{"location":"reactive_streams-Subscriber/#public-behaviours","text":"","title":"Public Behaviours"},{"location":"reactive_streams-Subscriber/#on_subscribe","text":"[Source] Invoked after calling Publisher.subscribe. No data will start flowing until Subscription.request is invoked. It is the responsibility of this Subscriber instance to call Subscription.request whenever more data is wanted. The Publisher will send notifications only in response to Subscription.request. be on_subscribe( s: Subscription iso)","title":"on_subscribe"},{"location":"reactive_streams-Subscriber/#parameters","text":"s: Subscription iso","title":"Parameters"},{"location":"reactive_streams-Subscriber/#on_next","text":"[Source] Data notification sent by the Publisher in response to requests to Subscription.request. be on_next( a: A)","title":"on_next"},{"location":"reactive_streams-Subscriber/#parameters_1","text":"a: A","title":"Parameters"},{"location":"reactive_streams-Subscriber/#on_error","text":"[Source] Failed terminal state. No further events will be sent even if Subscription.request is invoked again. be on_error( e: ReactiveError val)","title":"on_error"},{"location":"reactive_streams-Subscriber/#parameters_2","text":"e: ReactiveError val","title":"Parameters"},{"location":"reactive_streams-Subscriber/#on_complete","text":"[Source] Successful terminal state. No further events will be sent even if Subscription.request is invoked again. be on_complete()","title":"on_complete"},{"location":"reactive_streams-SubscriberManager/","text":"SubscriberManager[A: Any #share] \u00b6 [Source] Manages a subscriber list. interface ref SubscriberManager[A: Any #share] Public Functions \u00b6 min_request \u00b6 [Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val Returns \u00b6 U64 val max_request \u00b6 [Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val Returns \u00b6 U64 val queue_bound \u00b6 [Source] Returns the queue bound. fun box queue_bound() : U64 val Returns \u00b6 U64 val queue_size \u00b6 [Source] Returns the current queue size. fun box queue_size() : U64 val Returns \u00b6 U64 val subscriber_count \u00b6 [Source] Returns the current subscriber count. fun box subscriber_count() : U64 val Returns \u00b6 U64 val publish \u00b6 [Source] A ManagedPublisher should call this when it has data to publish. Subscribers with pending demand will be sent the data immediately. If any subscribers with no pending demand exist, the data will be kept on a queue to be sent when subscribers request additional data. The queue size can be bounded. If so, undelivered old data will be dropped if new data must be queued and the queue has hit its size limit. fun ref publish( a: A) : None val Parameters \u00b6 a: A Returns \u00b6 None val on_complete \u00b6 [Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val Returns \u00b6 None val on_error \u00b6 [Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val Parameters \u00b6 e: ReactiveError val Returns \u00b6 None val on_subscribe \u00b6 [Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val on_request \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val Parameters \u00b6 sub: Subscriber [A] tag n: U64 val Returns \u00b6 None val on_cancel \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val","title":"interface SubscriberManager"},{"location":"reactive_streams-SubscriberManager/#subscribermanagera-any-share","text":"[Source] Manages a subscriber list. interface ref SubscriberManager[A: Any #share]","title":"SubscriberManager[A: Any #share]"},{"location":"reactive_streams-SubscriberManager/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-SubscriberManager/#min_request","text":"[Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val","title":"min_request"},{"location":"reactive_streams-SubscriberManager/#returns","text":"U64 val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#max_request","text":"[Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val","title":"max_request"},{"location":"reactive_streams-SubscriberManager/#returns_1","text":"U64 val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#queue_bound","text":"[Source] Returns the queue bound. fun box queue_bound() : U64 val","title":"queue_bound"},{"location":"reactive_streams-SubscriberManager/#returns_2","text":"U64 val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#queue_size","text":"[Source] Returns the current queue size. fun box queue_size() : U64 val","title":"queue_size"},{"location":"reactive_streams-SubscriberManager/#returns_3","text":"U64 val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#subscriber_count","text":"[Source] Returns the current subscriber count. fun box subscriber_count() : U64 val","title":"subscriber_count"},{"location":"reactive_streams-SubscriberManager/#returns_4","text":"U64 val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#publish","text":"[Source] A ManagedPublisher should call this when it has data to publish. Subscribers with pending demand will be sent the data immediately. If any subscribers with no pending demand exist, the data will be kept on a queue to be sent when subscribers request additional data. The queue size can be bounded. If so, undelivered old data will be dropped if new data must be queued and the queue has hit its size limit. fun ref publish( a: A) : None val","title":"publish"},{"location":"reactive_streams-SubscriberManager/#parameters","text":"a: A","title":"Parameters"},{"location":"reactive_streams-SubscriberManager/#returns_5","text":"None val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#on_complete","text":"[Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val","title":"on_complete"},{"location":"reactive_streams-SubscriberManager/#returns_6","text":"None val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#on_error","text":"[Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val","title":"on_error"},{"location":"reactive_streams-SubscriberManager/#parameters_1","text":"e: ReactiveError val","title":"Parameters"},{"location":"reactive_streams-SubscriberManager/#returns_7","text":"None val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#on_subscribe","text":"[Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val","title":"on_subscribe"},{"location":"reactive_streams-SubscriberManager/#parameters_2","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-SubscriberManager/#returns_8","text":"None val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#on_request","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val","title":"on_request"},{"location":"reactive_streams-SubscriberManager/#parameters_3","text":"sub: Subscriber [A] tag n: U64 val","title":"Parameters"},{"location":"reactive_streams-SubscriberManager/#returns_9","text":"None val","title":"Returns"},{"location":"reactive_streams-SubscriberManager/#on_cancel","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val","title":"on_cancel"},{"location":"reactive_streams-SubscriberManager/#parameters_4","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-SubscriberManager/#returns_10","text":"None val","title":"Returns"},{"location":"reactive_streams-Subscription/","text":"Subscription \u00b6 [Source] A Subscription represents a one-to-one lifecycle of a Subscriber subscribing to a Publisher. It can only be used by a single Subscriber. It is used to both signal desire for data and cancel demand (and allow resource cleanup). interface ref Subscription Public Functions \u00b6 request \u00b6 [Source] No events will be sent by a Publisher until demand is signaled via this method. It can be called however often and whenever needed\u2014but the outstanding cumulative demand must never exceed U64.max_value. An outstanding cumulative demand of U64.max_value may be treated by the Publisher as \"effectively unbounded\". Whatever has been requested can be sent by the Publisher so only signal demand for what can be safely handled. A Publisher can send less than is requested if the stream ends but then must emit either Subscriber.on_error or Subscriber.on_complete. fun ref request( n: U64 val) : None val Parameters \u00b6 n: U64 val Returns \u00b6 None val cancel \u00b6 [Source] Request the Publisher to stop sending data and clean up resources. Data may still be sent to meet previously signalled demand after calling cancel as this request is asynchronous. fun ref cancel() : None val Returns \u00b6 None val","title":"interface Subscription"},{"location":"reactive_streams-Subscription/#subscription","text":"[Source] A Subscription represents a one-to-one lifecycle of a Subscriber subscribing to a Publisher. It can only be used by a single Subscriber. It is used to both signal desire for data and cancel demand (and allow resource cleanup). interface ref Subscription","title":"Subscription"},{"location":"reactive_streams-Subscription/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-Subscription/#request","text":"[Source] No events will be sent by a Publisher until demand is signaled via this method. It can be called however often and whenever needed\u2014but the outstanding cumulative demand must never exceed U64.max_value. An outstanding cumulative demand of U64.max_value may be treated by the Publisher as \"effectively unbounded\". Whatever has been requested can be sent by the Publisher so only signal demand for what can be safely handled. A Publisher can send less than is requested if the stream ends but then must emit either Subscriber.on_error or Subscriber.on_complete. fun ref request( n: U64 val) : None val","title":"request"},{"location":"reactive_streams-Subscription/#parameters","text":"n: U64 val","title":"Parameters"},{"location":"reactive_streams-Subscription/#returns","text":"None val","title":"Returns"},{"location":"reactive_streams-Subscription/#cancel","text":"[Source] Request the Publisher to stop sending data and clean up resources. Data may still be sent to meet previously signalled demand after calling cancel as this request is asynchronous. fun ref cancel() : None val","title":"cancel"},{"location":"reactive_streams-Subscription/#returns_1","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/","text":"Unicast[A: Any #share] \u00b6 [Source] Send data to a single subscriber. class ref Unicast[A: Any #share] Constructors \u00b6 create \u00b6 [Source] Create a Unicast for a given ManagedPublisher. new ref create( pub: ManagedPublisher[A] tag, qbound: U64 val = call) : Unicast[A] ref^ Parameters \u00b6 pub: ManagedPublisher [A] tag qbound: U64 val = call Returns \u00b6 Unicast [A] ref^ Public Functions \u00b6 min_request \u00b6 [Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val Returns \u00b6 U64 val max_request \u00b6 [Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val Returns \u00b6 U64 val queue_bound \u00b6 [Source] Returns the queue bound. fun box queue_bound() : U64 val Returns \u00b6 U64 val queue_size \u00b6 [Source] Returns the current queue size. fun box queue_size() : U64 val Returns \u00b6 U64 val subscriber_count \u00b6 [Source] Returns the current subscriber count. fun box subscriber_count() : U64 val Returns \u00b6 U64 val publish \u00b6 [Source] Send data to the subscriber. fun ref publish( a: A) : None val Parameters \u00b6 a: A Returns \u00b6 None val on_complete \u00b6 [Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val Returns \u00b6 None val on_error \u00b6 [Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val Parameters \u00b6 e: ReactiveError val Returns \u00b6 None val on_subscribe \u00b6 [Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val on_request \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val Parameters \u00b6 sub: Subscriber [A] tag n: U64 val Returns \u00b6 None val on_cancel \u00b6 [Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val Parameters \u00b6 sub: Subscriber [A] tag Returns \u00b6 None val","title":"class Unicast"},{"location":"reactive_streams-Unicast/#unicasta-any-share","text":"[Source] Send data to a single subscriber. class ref Unicast[A: Any #share]","title":"Unicast[A: Any #share]"},{"location":"reactive_streams-Unicast/#constructors","text":"","title":"Constructors"},{"location":"reactive_streams-Unicast/#create","text":"[Source] Create a Unicast for a given ManagedPublisher. new ref create( pub: ManagedPublisher[A] tag, qbound: U64 val = call) : Unicast[A] ref^","title":"create"},{"location":"reactive_streams-Unicast/#parameters","text":"pub: ManagedPublisher [A] tag qbound: U64 val = call","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns","text":"Unicast [A] ref^","title":"Returns"},{"location":"reactive_streams-Unicast/#public-functions","text":"","title":"Public Functions"},{"location":"reactive_streams-Unicast/#min_request","text":"[Source] Returns the lowest request count of all subscribers. fun box min_request() : U64 val","title":"min_request"},{"location":"reactive_streams-Unicast/#returns_1","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Unicast/#max_request","text":"[Source] Returns the highest request count of all subscribers. fun box max_request() : U64 val","title":"max_request"},{"location":"reactive_streams-Unicast/#returns_2","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Unicast/#queue_bound","text":"[Source] Returns the queue bound. fun box queue_bound() : U64 val","title":"queue_bound"},{"location":"reactive_streams-Unicast/#returns_3","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Unicast/#queue_size","text":"[Source] Returns the current queue size. fun box queue_size() : U64 val","title":"queue_size"},{"location":"reactive_streams-Unicast/#returns_4","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Unicast/#subscriber_count","text":"[Source] Returns the current subscriber count. fun box subscriber_count() : U64 val","title":"subscriber_count"},{"location":"reactive_streams-Unicast/#returns_5","text":"U64 val","title":"Returns"},{"location":"reactive_streams-Unicast/#publish","text":"[Source] Send data to the subscriber. fun ref publish( a: A) : None val","title":"publish"},{"location":"reactive_streams-Unicast/#parameters_1","text":"a: A","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns_6","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/#on_complete","text":"[Source] A ManagedPublisher should call this when it has no more data to produce. fun ref on_complete() : None val","title":"on_complete"},{"location":"reactive_streams-Unicast/#returns_7","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/#on_error","text":"[Source] A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. fun ref on_error( e: ReactiveError val) : None val","title":"on_error"},{"location":"reactive_streams-Unicast/#parameters_2","text":"e: ReactiveError val","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns_8","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/#on_subscribe","text":"[Source] A ManagedPublisher should call this when it receives Publisher.subscribe. fun ref on_subscribe( sub: Subscriber[A] tag) : None val","title":"on_subscribe"},{"location":"reactive_streams-Unicast/#parameters_3","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns_9","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/#on_request","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_request. fun ref on_request( sub: Subscriber[A] tag, n: U64 val) : None val","title":"on_request"},{"location":"reactive_streams-Unicast/#parameters_4","text":"sub: Subscriber [A] tag n: U64 val","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns_10","text":"None val","title":"Returns"},{"location":"reactive_streams-Unicast/#on_cancel","text":"[Source] A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. fun ref on_cancel( sub: Subscriber[A] tag) : None val","title":"on_cancel"},{"location":"reactive_streams-Unicast/#parameters_5","text":"sub: Subscriber [A] tag","title":"Parameters"},{"location":"reactive_streams-Unicast/#returns_11","text":"None val","title":"Returns"},{"location":"src/reactive_streams/broadcast/","text":"use \"collections\" class Broadcast[A: Any #share] is SubscriberManager[A] \"\"\" Broadcasts data to all subscribers. \"\"\" let _pub: ManagedPublisher[A] let _map: MapIs[Subscriber[A], _SubscriberState] = _map.create() let _queue: List[A] = _queue.create() let _qbound: U64 var _min_request: U64 = 0 var _max_request: U64 = 0 new create(pub: ManagedPublisher[A], qbound: U64 = U64.max_value()) => \"\"\" Create a Broadcast for a given ManagedPublisher. \"\"\" _pub = pub _qbound = if qbound == 0 then 1 else qbound end fun min_request(): U64 => \"\"\" Returns the lowest request count of all subscribers. \"\"\" _min_request fun max_request(): U64 => \"\"\" Returns the highest request count of all subscribers. \"\"\" _max_request fun queue_bound(): U64 => \"\"\" Returns the queue bound. \"\"\" _qbound fun queue_size(): U64 => \"\"\" Returns the current queue size. \"\"\" _queue.size().u64() fun subscriber_count(): U64 => \"\"\" Returns the current subscriber count. \"\"\" _map.size().u64() fun ref publish(a: A) => \"\"\" Send data to all subscribers. \"\"\" if _map.size() == 0 then // Drop if we have no subscribers. return end if _max_request == 0 then // No subscribers have pending demand. if _queue.size().u64() == _qbound then try _queue.shift()? end end _queue.push(a) return end if _min_request > 0 then // All subscribers have pending demand. Send the new data to them all, // reducing each one's request count. Also reduce _min_request. _min_request = _min_request - 1 _max_request = _max_request - 1 for (sub, state) in _map.pairs() do state.request = state.request - 1 sub.on_next(a) end return end if _queue.size().u64() == _qbound then // We have hit our bound and must drop from the queue. try _queue.shift()? _queue.push(a) for (sub, state) in _map.pairs() do if state.request > 0 then // The subscriber has pending demand. Leave the queue_position // where it is, but reduce the request count. state.request = state.request - 1 sub.on_next(a) else // The subscriber has no pending demand. Since we dropped from the // queue, move the queue_position back one. if state.queue_position > 0 then state.queue_position = state.queue_position - 1 end end end return end end // We aren't at the queue bound. _queue.push(a) let pos = _queue.size().u64() for (sub, state) in _map.pairs() do if state.request > 0 then // The subscriber has pending demand. Move the queue_position to the // current tail, and reduce the request count. state.request = state.request - 1 state.queue_position = pos sub.on_next(a) end end fun ref on_complete() => \"\"\" A ManagedPublisher should call this when it has no more data to produce. \"\"\" for sub in _map.keys() do sub.on_complete() end _reset() fun ref on_error(e: ReactiveError) => \"\"\" A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. \"\"\" for sub in _map.keys() do sub.on_error(e) end _reset() fun ref _reset() => \"\"\" Reset after completion or error. \"\"\" _map.clear() _queue.clear() _min_request = 0 _max_request = 0 fun ref on_subscribe(sub: Subscriber[A]) => \"\"\" A ManagedPublisher should call this when it receives Publisher.subscribe. \"\"\" let prev = _map(sub) = _SubscriberState if prev isnt None then sub.on_error(SubscribedAlready) end sub.on_subscribe(_Subscription[A](sub, _pub)) _min_request = 0 fun ref on_request(sub: Subscriber[A], n: U64) => \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_request. \"\"\" try let state = _map(sub)? var inc = n if (state.request == 0) and (state.queue_position < _queue.size().u64()) then // Send pending backlog. var count = inc.min(_queue.size().u64() - state.queue_position) try var node = _queue.index(state.queue_position.usize())? for i in Range[U64](0, count) do sub.on_next(node()?) if node.has_next() then node = node.next() as ListNode[A] end end end let adjust = state.queue_position == 0 state.queue_position = state.queue_position + count inc = inc - count // Possibly djust the queue if we were blocking the head. if adjust then _adjust_queue() end end if inc > 0 then let recalc = state.request == _min_request if (state.request + inc) < state.request then state.request = U64.max_value() else state.request = state.request + inc end _max_request = _max_request.max(state.request) if recalc then _find_min_request() end end end fun ref on_cancel(sub: Subscriber[A]) => \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. \"\"\" try (_, let state) = _map.remove(sub)? if (state.request == 0) and (state.queue_position == 0) and (_queue.size() > 0) then // If this subscriber was blocking at the head of the queue, we may be // able to adjust the queue. _adjust_queue() end end fun ref _find_min_request() => \"\"\" Recalculate the _min_request value. \"\"\" _min_request = U64.max_value() for state in _map.values() do _min_request = _min_request.min(state.request) end fun ref _adjust_queue() => \"\"\" When a subscriber is removed or gets sent backlog data, call this to drop elements from the queue that are no longer needed. \"\"\" var min_queue_position = U64.max_value() for state in _map.values() do min_queue_position = min_queue_position.min(state.queue_position) end if min_queue_position > 0 then try for i in Range[U64](0, min_queue_position) do _queue.shift()? end end for state in _map.values() do state.queue_position = state.queue_position - min_queue_position end end class _SubscriberState \"\"\" Keeps track of the pending demand and queue position for a subscriber. \"\"\" var request: U64 = 0 var queue_position: U64 = 0 fun ref clear() => request = 0 queue_position = 0","title":"Broadcast"},{"location":"src/reactive_streams/errors/","text":"trait val ReactiveError primitive SubscribedAlready is ReactiveError primitive PublisherFull is ReactiveError","title":"Errors"},{"location":"src/reactive_streams/managedpublisher/","text":"interface tag ManagedPublisher[A: Any #share] is Publisher[A] \"\"\" A ManagedPublisher must have a SubscriberManager and give access to it. \"\"\" fun ref _subscriber_manager(): SubscriberManager[A] \"\"\" Return the SubscriberManager associated with this ManagedPublisher. \"\"\" be subscribe(s: Subscriber[A]) => \"\"\" A ManagedPublisher must respond by calling SubscriberManager._on_subscribe. \"\"\" _subscriber_manager().on_subscribe(s) be on_request(s: Subscriber[A], n: U64) => \"\"\" A ManagedPublisher must respond by calling SubscriberManager._on_request. \"\"\" _subscriber_manager().on_request(s, n) be on_cancel(s: Subscriber[A]) => \"\"\" A ManagedPublisher must respond by calling SubscriberManager._on_cancel. \"\"\" _subscriber_manager().on_cancel(s)","title":"Managedpublisher"},{"location":"src/reactive_streams/processor/","text":"interface tag Processor[A: Any #share, B: Any #share] is (Subscriber[A] & Publisher[B]) \"\"\" A Processor represents a processing stage\u2014which is both a Subscriber and a Publisher and obeys the contracts of both. \"\"\"","title":"Processor"},{"location":"src/reactive_streams/publisher/","text":"interface tag Publisher[A: Any #share] \"\"\" A Publisher is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s). A Publisher can serve multiple Subscribers subscribed dynamically at various points in time. \"\"\" be subscribe(s: Subscriber[A]) \"\"\" Request Publisher to start streaming data. This is a \"factory method\" and can be called multiple times, each time starting a new Subscription. Each Subscription will work for only a single Subscriber. A Subscriber should only subscribe once to a single Publisher. If the Publisher rejects the subscription attempt or otherwise fails it will signal the error via Subscriber.on_error. \"\"\"","title":"Publisher"},{"location":"src/reactive_streams/subscriber/","text":"interface tag Subscriber[A: Any #share] \"\"\" Will receive call to on_subscribe once after passing an instance of Subscriber to Publisher.subscribe. No further notifications will be received until Subscription.request is called. After signaling demand: * One or more invocations of on_next up to the maximum number defined by Subscription.request * Single invocation of on_error or on_complete which signals a terminal state after which no further events will be sent. Demand can be signaled via Subscription.request whenever the Subscriber instance is capable of handling more. \"\"\" be on_subscribe(s: Subscription iso) => \"\"\" Invoked after calling Publisher.subscribe. No data will start flowing until Subscription.request is invoked. It is the responsibility of this Subscriber instance to call Subscription.request whenever more data is wanted. The Publisher will send notifications only in response to Subscription.request. \"\"\" None be on_next(a: A) => \"\"\" Data notification sent by the Publisher in response to requests to Subscription.request. \"\"\" None be on_error(e: ReactiveError) => \"\"\" Failed terminal state. No further events will be sent even if Subscription.request is invoked again. \"\"\" None be on_complete() => \"\"\" Successful terminal state. No further events will be sent even if Subscription.request is invoked again. \"\"\" None","title":"Subscriber"},{"location":"src/reactive_streams/subscribermanager/","text":"interface SubscriberManager[A: Any #share] \"\"\" Manages a subscriber list. \"\"\" fun min_request(): U64 \"\"\" Returns the lowest request count of all subscribers. \"\"\" fun max_request(): U64 \"\"\" Returns the highest request count of all subscribers. \"\"\" fun queue_bound(): U64 \"\"\" Returns the queue bound. \"\"\" fun queue_size(): U64 \"\"\" Returns the current queue size. \"\"\" fun subscriber_count(): U64 \"\"\" Returns the current subscriber count. \"\"\" fun ref publish(a: A) \"\"\" A ManagedPublisher should call this when it has data to publish. Subscribers with pending demand will be sent the data immediately. If any subscribers with no pending demand exist, the data will be kept on a queue to be sent when subscribers request additional data. The queue size can be bounded. If so, undelivered old data will be dropped if new data must be queued and the queue has hit its size limit. \"\"\" fun ref on_complete() \"\"\" A ManagedPublisher should call this when it has no more data to produce. \"\"\" fun ref on_error(e: ReactiveError) \"\"\" A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. \"\"\" fun ref on_subscribe(sub: Subscriber[A]) \"\"\" A ManagedPublisher should call this when it receives Publisher.subscribe. \"\"\" fun ref on_request(sub: Subscriber[A], n: U64) \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_request. \"\"\" fun ref on_cancel(sub: Subscriber[A]) \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. \"\"\" class iso _Subscription[A: Any #share] is Subscription \"\"\" Implements Subscription[A], allowing a subscriber to a ManagedPublisher to request more data or cancel its subscription. \"\"\" let _sub: Subscriber[A] let _pub: ManagedPublisher[A] var _cancelled: Bool = false new iso create(sub: Subscriber[A], pub: ManagedPublisher[A]) => \"\"\" Create a _Subscription for a given subscriber and publisher. \"\"\" _sub = sub _pub = pub fun ref request(n: U64) => \"\"\" Request more data. NOP if the subscription has been cancelled. \"\"\" if not _cancelled and (n > 0) then _pub.on_request(_sub, n) end fun ref cancel() => \"\"\" Cancel the subscription. NOP if it has already been cancelled. \"\"\" if not _cancelled then _cancelled = true _pub.on_cancel(_sub) end","title":"Subscribermanager"},{"location":"src/reactive_streams/subscription/","text":"interface Subscription \"\"\" A Subscription represents a one-to-one lifecycle of a Subscriber subscribing to a Publisher. It can only be used by a single Subscriber. It is used to both signal desire for data and cancel demand (and allow resource cleanup). \"\"\" fun ref request(n: U64) => \"\"\" No events will be sent by a Publisher until demand is signaled via this method. It can be called however often and whenever needed\u2014but the outstanding cumulative demand must never exceed U64.max_value. An outstanding cumulative demand of U64.max_value may be treated by the Publisher as \"effectively unbounded\". Whatever has been requested can be sent by the Publisher so only signal demand for what can be safely handled. A Publisher can send less than is requested if the stream ends but then must emit either Subscriber.on_error or Subscriber.on_complete. \"\"\" None fun ref cancel() => \"\"\" Request the Publisher to stop sending data and clean up resources. Data may still be sent to meet previously signalled demand after calling cancel as this request is asynchronous. \"\"\" None class NoSubscription is Subscription","title":"Subscription"},{"location":"src/reactive_streams/unicast/","text":"use \"collections\" class Unicast[A: Any #share] \"\"\" Send data to a single subscriber. \"\"\" let _pub: ManagedPublisher[A] var _sub: (Subscriber[A] | None) = None var _request: U64 = 0 let _queue: List[A] = _queue.create() let _qbound: U64 new create(pub: ManagedPublisher[A], qbound: U64 = U64.max_value()) => \"\"\" Create a Unicast for a given ManagedPublisher. \"\"\" _pub = pub _qbound = if qbound == 0 then 1 else qbound end fun min_request(): U64 => \"\"\" Returns the lowest request count of all subscribers. \"\"\" _request fun max_request(): U64 => \"\"\" Returns the highest request count of all subscribers. \"\"\" _request fun queue_bound(): U64 => \"\"\" Returns the queue bound. \"\"\" _qbound fun queue_size(): U64 => \"\"\" Returns the current queue size. \"\"\" _queue.size().u64() fun subscriber_count(): U64 => \"\"\" Returns the current subscriber count. \"\"\" if _sub is None then 0 else 1 end fun ref publish(a: A) => \"\"\" Send data to the subscriber. \"\"\" try let sub = _sub as Subscriber[A] if _request > 0 then _request = _request - 1 sub.on_next(a) else if _queue.size().u64() == _qbound then _queue.shift()? end _queue.push(a) end end fun ref on_complete() => \"\"\" A ManagedPublisher should call this when it has no more data to produce. \"\"\" try let sub = _sub as Subscriber[A] sub.on_complete() _sub = None _request = 0 end _queue.clear() fun ref on_error(e: ReactiveError) => \"\"\" A ManagedPublisher should call this when its internal state has resulted in an error that should be propagated to all subscribers. \"\"\" try let sub = _sub as Subscriber[A] sub.on_error(e) _sub = None _request = 0 end _queue.clear() fun ref on_subscribe(sub: Subscriber[A]) => \"\"\" A ManagedPublisher should call this when it receives Publisher.subscribe. \"\"\" if _sub is None then _sub = sub sub.on_subscribe(_Subscription[A](sub, _pub)) elseif _sub is sub then _request = 0 _queue.clear() sub.on_error(SubscribedAlready) sub.on_subscribe(_Subscription[A](sub, _pub)) else let subscription = _Subscription[A](sub, _pub) subscription.cancel() sub.on_subscribe(consume subscription) sub.on_error(PublisherFull) end fun ref on_request(sub: Subscriber[A], n: U64) => \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_request. \"\"\" if sub is _sub then _request = _request + n while (_queue.size() > 0) and (_request > 0) do try sub.on_next(_queue.shift()?) _request = _request - 1 end end end fun ref on_cancel(sub: Subscriber[A]) => \"\"\" A ManagedPublisher should call this when it receives ManagedPublisher._on_cancel. \"\"\" if sub is _sub then _sub = None _request = 0 _queue.clear() end","title":"Unicast"}]}